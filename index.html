<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>QR Сканер — Мини-приложение</title>
  <style>
    :root{--bg:#071021;--card:#0f1724;--accent:#11a37f;--muted:#9aa4b2;--white:#eef2f7}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,"Segoe UI",Roboto,Arial;background:linear-gradient(180deg,#071021,#071827);color:var(--white)}
    .app{max-width:480px;margin:0 auto;padding:16px}
    header{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:8px}
    header h1{font-size:18px;margin:0} header p{margin:0;font-size:12px;color:var(--muted)}
    .viewer{position:relative;width:100%;height:60vh;min-height:380px;background:#000;border-radius:12px;overflow:hidden}
    video{width:100%;height:100%;object-fit:cover;transform:scaleX(-1)}
    canvas{display:none}
    .overlay{position:absolute;inset:0;pointer-events:none;display:flex;align-items:center;justify-content:center}
    .frame{width:78%;aspect-ratio:1/1;border-radius:10px;box-shadow:0 0 0 9999px rgba(0,0,0,0.35) inset;border:2px dashed rgba(255,255,255,0.12);display:flex;align-items:center;justify-content:center}
    .hint{position:absolute;bottom:12px;left:12px;right:12px;text-align:center;font-size:13px;color:var(--muted);pointer-events:auto}
    .controls{margin-top:12px;display:flex;gap:8px;justify-content:space-between;align-items:center}
    .btn{background:var(--card);border:1px solid rgba(255,255,255,0.04);color:var(--white);padding:10px 12px;border-radius:10px;font-size:15px;flex:1;text-align:center}
    .btn.primary{background:linear-gradient(90deg,var(--accent),#0bc09b);color:#021016;font-weight:600;flex:2}
    .small{font-size:13px;padding:8px 10px}
    .result{margin-top:12px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:10px;padding:10px;font-size:14px;color:var(--white);word-break:break-all}
    .muted{color:var(--muted);font-size:13px}
    .row{display:flex;gap:8px;margin-top:8px}
    input[type=file]{display:none}
    footer{margin-top:14px;text-align:center;color:var(--muted);font-size:12px}
    .status {margin-top:10px;font-size:13px;color:var(--muted)}
    .debug {margin-top:12px;padding:8px;background:#071827;border-radius:8px;font-size:12px;white-space:pre-wrap;max-height:180px;overflow:auto}
    .confirm {position:fixed;left:0;right:0;bottom:12px;margin:0 auto;max-width:440px;padding:12px;background:linear-gradient(180deg,#042526,#063f33);border-radius:10px;display:flex;gap:8px;align-items:center;box-shadow:0 8px 30px rgba(0,0,0,0.6)}
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div>
        <h1>QR Сканер</h1>
        <p>Откройте камеру и наведите QR в рамку</p>
      </div>
      <div class="muted">Мини-приложение</div>
    </header>

    <main>
      <div class="viewer" id="viewer">
        <video id="video" autoplay playsinline></video>
        <canvas id="canvas"></canvas>
        <div class="overlay" aria-hidden="true">
          <div class="frame" id="frame"></div>
        </div>
      </div>

      <div class="hint muted" id="hint">Используйте заднюю камеру. Если WebApp недоступен — откройте приложение Telegram через кнопку бота.</div>

      <div class="controls">
        <button class="btn small" id="toggleTorch">Вкл/Выкл фонарик</button>
        <button class="btn small" id="switchCam">Сменить камеру</button>
        <button class="btn primary" id="stopStart">Остановить</button>
      </div>

      <div class="row">
        <label class="btn small" for="pickImage">Загрузить фото</label>
        <input id="pickImage" type="file" accept="image/*">
        <button class="btn small" id="copyBtn">Копировать</button>
        <button class="btn small" id="sendBtn">Отправить в Telegram</button>
      </div>

      <div class="result" id="result">Результат: <span id="resultText" class="muted">пока не найдено</span></div>

      <div class="status" id="status">Статус: ждём Telegram WebApp...</div>

      <div class="debug" id="debug" style="display:none"></div>

      <footer>Если камера не работает — разрешите доступ к камере в настройках браузера / Telegram.</footer>
    </main>
  </div>

  <!-- jsQR CDN -->
  <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>

  <script>
    // Helper: ждём появления Telegram.WebApp (promise, таймаут)
    function waitForTelegram(timeout = 3000) {
      return new Promise(resolve => {
        const start = Date.now();
        (function check() {
          if (window.Telegram?.WebApp) return resolve(window.Telegram.WebApp);
          if (Date.now() - start > timeout) return resolve(null);
          setTimeout(check, 100);
        })();
      });
    }

    // UI элементы
    const statusEl = document.getElementById('status');
    const debugEl = document.getElementById('debug');
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const resultTextEl = document.getElementById('resultText');
    const sendBtn = document.getElementById('sendBtn');
    const copyBtn = document.getElementById('copyBtn');
    const stopStartBtn = document.getElementById('stopStart');
    const toggleTorchBtn = document.getElementById('toggleTorch');
    const switchCamBtn = document.getElementById('switchCam');
    const pickImage = document.getElementById('pickImage');

    let tg = null;
    let scanning = true;
    let currentStream = null;
    let useFront = false;
    let torchOn = false;
    let lastResult = "";

    async function init() {
      tg = await waitForTelegram(3500);
      if (!tg) {
        statusEl.textContent = 'Статус: Telegram WebApp API недоступен. Откройте страницу именно из кнопки бота в мобильном приложении Telegram.';
        statusEl.style.color = 'orange';
        debugEl.style.display = 'block';
        debugEl.textContent = 'Debug:\n' + JSON.stringify({
          userAgent: navigator.userAgent,
          location: location.href,
          referrer: document.referrer,
          hasTelegramObject: !!window.Telegram,
          hasTelegramWebApp: !!window.Telegram?.WebApp
        }, null, 2);
        // Запускаем камеру даже если tg отсутствует — чтобы можно было тестить, но sendBtn покажет предупреждение
        startCamera().catch(()=>{});
        return;
      }

      try { tg.ready(); } catch(e){}
      statusEl.textContent = 'Статус: Telegram WebApp доступен ✓';
      statusEl.style.color = 'lightgreen';
      debugEl.style.display = 'block';
      debugEl.textContent = 'Telegram.WebApp properties:\n' + JSON.stringify({
        version: tg.version ?? '(unknown)',
        initData: !!tg.initData,
        initDataUnsafe: !!tg.initDataUnsafe
      }, null, 2);

      // старт камеры
      await startCamera();
    }

    // Camera functions
    async function startCamera() {
      stopCamera();
      const constraints = {
        audio: false,
        video: {
          facingMode: useFront ? "user" : { ideal: "environment" },
          width: { ideal: 1280 },
          height: { ideal: 720 }
        }
      };
      try {
        currentStream = await navigator.mediaDevices.getUserMedia(constraints);
        video.srcObject = currentStream;
        video.addEventListener('loadedmetadata', () => {
          if (!useFront) video.style.transform = "scaleX(1)"; else video.style.transform = "scaleX(-1)";
        });
        await video.play();
        scanning = true;
        stopStartBtn.textContent = "Остановить";
        requestAnimationFrame(tick);
      } catch (err) {
        console.error("Ошибка доступа к камере:", err);
        alert("Не удалось получить доступ к камере: " + (err.message || err));
      }
    }

    function stopCamera() {
      scanning = false;
      if (currentStream) {
        currentStream.getTracks().forEach(t => t.stop());
        currentStream = null;
      }
      stopStartBtn.textContent = "Запустить";
    }

    async function toggleTorch() {
      if (!currentStream) return;
      const track = currentStream.getVideoTracks()[0];
      if (!track) return;
      const cap = track.getCapabilities?.();
      if (!cap || !cap.torch) {
        alert("Фонарик не поддерживается на этом устройстве/браузере.");
        return;
      }
      try {
        torchOn = !torchOn;
        await track.applyConstraints({ advanced: [{ torch: torchOn }] });
        toggleTorchBtn.textContent = torchOn ? "Фонарик: Вкл" : "Фонарик: Выкл";
      } catch (e) {
        console.error("toggleTorch error:", e);
        alert("Не удалось переключить фонарик: " + e.message);
      }
    }

    function tick() {
      if (!scanning || video.readyState !== video.HAVE_ENOUGH_DATA) {
        requestAnimationFrame(tick);
        return;
      }
      const vw = video.videoWidth;
      const vh = video.videoHeight;
      if (!vw || !vh) { requestAnimationFrame(tick); return; }
      canvas.width = vw; canvas.height = vh;
      ctx.drawImage(video, 0, 0, vw, vh);

      const side = Math.min(vw, vh);
      const sx = (vw - side) / 2;
      const sy = (vh - side) / 2;
      let imageData;
      try {
        imageData = ctx.getImageData(sx, sy, side, side);
      } catch(e){
        requestAnimationFrame(tick);
        return;
      }

      const code = jsQR(imageData.data, imageData.width, imageData.height, { inversionAttempts: "attemptBoth" });
      if (code) {
        drawBoundingBox(code.location, sx, sy, vw, vh);
        if (code.data && code.data !== lastResult) {
          lastResult = code.data;
          onQrFound(code.data);
        }
      }
      requestAnimationFrame(tick);
    }

    function drawBoundingBox(loc, sx, sy, vw, vh) {
      ctx.strokeStyle = "rgba(17,163,127,0.9)";
      ctx.lineWidth = Math.max(2, Math.min(vw, vh) * 0.005);
      ctx.beginPath();
      ctx.moveTo(sx + loc.topLeftCorner.x, sy + loc.topLeftCorner.y);
      ctx.lineTo(sx + loc.topRightCorner.x, sy + loc.topRightCorner.y);
      ctx.lineTo(sx + loc.bottomRightCorner.x, sy + loc.bottomRightCorner.y);
      ctx.lineTo(sx + loc.bottomLeftCorner.x, sy + loc.bottomLeftCorner.y);
      ctx.closePath();
      ctx.stroke();
    }

    // Когда QR найден — показываем результат и предлагаем отправить
    function onQrFound(text) {
      resultTextEl.textContent = text;
      resultTextEl.classList.remove('muted');
      // Авто-отправка отключена: пользователь должен подтвердить
      // Можно показать небольшое уведомление / подтвердить отправку
      showConfirmSend(text);
    }

    // Подтверждение отправки (внизу)
    function showConfirmSend(text) {
      // если уже есть — не показываем дубликат
      if (document.getElementById('confirmBox')) return;
      const box = document.createElement('div');
      box.id = 'confirmBox';
      box.className = 'confirm';
      box.innerHTML = `
        <div style="flex:1">
          <div style="font-size:13px;color:#dff5ea">QR найден</div>
          <div style="font-size:12px;color:#bfead1;word-break:break-all">${text}</div>
        </div>
        <div style="display:flex;gap:8px">
          <button id="confirmSendBtn" class="btn small">Отправить</button>
          <button id="dismissBtn" class="btn small">Закрыть</button>
        </div>
      `;
      document.body.appendChild(box);
      document.getElementById('confirmSendBtn').addEventListener('click', () => {
        sendDataToBot(text);
        removeConfirm();
      });
      document.getElementById('dismissBtn').addEventListener('click', () => {
        removeConfirm();
      });
    }

    function removeConfirm() {
      const el = document.getElementById('confirmBox');
      if (el) el.remove();
    }

    // Отправка в бот через Telegram WebApp API (tg.sendData)
    function sendDataToBot(text) {
      if (!tg) {
        alert("Telegram WebApp API недоступен. Откройте страницу из бота в мобильном Telegram.");
        return;
      }
      try {
        tg.sendData(JSON.stringify({ qr: text }));
        // опционально закрываем WebApp:
        // try { tg.close(); } catch(e){}
      } catch (e) {
        console.error("sendData error", e);
        alert("Не удалось отправить данные в Telegram: " + e.message);
      }
    }

    // UI handlers
    sendBtn.addEventListener('click', () => {
      const txt = lastResult || resultTextEl.textContent || "";
      if (!txt || txt === 'пока не найдено') return alert("QR ещё не распознан.");
      // Если tg отсутствует — покажем понятное сообщение
      if (!tg) return alert("Telegram WebApp API недоступен. Откройте страницу из бота в мобильном Telegram.");
      // просим подтвердить
      showConfirmSend(txt);
    });

    copyBtn.addEventListener('click', async () => {
      const txt = lastResult || resultTextEl.textContent || "";
      if (!txt || txt === 'пока не найдено') return alert("QR ещё не распознан.");
      try {
        await navigator.clipboard.writeText(txt);
        copyBtn.textContent = "Скопировано";
        setTimeout(()=>copyBtn.textContent = "Копировать", 1200);
      } catch (e) {
        alert("Не удалось скопировать: " + e.message);
      }
    });

    stopStartBtn.addEventListener('click', () => {
      if (scanning) stopCamera(); else startCamera();
    });

    toggleTorchBtn.addEventListener('click', () => toggleTorch());
    switchCamBtn.addEventListener('click', async () => { useFront = !useFront; await startCamera(); });

    pickImage.addEventListener('change', async (ev) => {
      const f = ev.target.files && ev.target.files[0];
      if (!f) return;
      const img = new Image();
      img.onload = () => {
        const w = img.width, h = img.height;
        canvas.width = w; canvas.height = h;
        ctx.drawImage(img, 0, 0, w, h);
        const data = ctx.getImageData(0,0,w,h);
        const code = jsQR(data.data, data.width, data.height, { inversionAttempts: "attemptBoth" });
        if (code && code.data) {
          lastResult = code.data;
          onQrFound(code.data);
          alert("QR найден: " + code.data);
        } else {
          alert("QR не найден на изображении.");
        }
      };
      img.onerror = () => alert("Не удалось загрузить изображение.");
      img.src = URL.createObjectURL(f);
      pickImage.value = "";
    });

    // init on load
    (async () => {
      await init();
    })();

    // cleanup
    window.addEventListener('pagehide', stopCamera);
    window.addEventListener('beforeunload', stopCamera);
  </script>
</body>
</html>
